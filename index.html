<!doctype html>
<html>
  <head>
    <title>Socket.IO chat</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
    </style>
  </head>
  <body>
    <div>
      <ul id="messages"></ul>
      <form action="">
        <input id="m" autocomplete="off" /><button>Send</button>
      </form>
    </div>
    <div>
      <h1>BLAKE2s in JavaScript</h1>

      Input:<br>
      <div>
        <textarea style="float:left;" id=input cols=60 rows=10>Enter some text and press the button.</textarea>
        <textarea style="float:right;" id=output cols=60 rows=10>Output of blockchain going here...</textarea>
      </div>
      <div style="clear:all;" />
      <div>
        Digest length: <input id=digest-length type=number min=1 max=32 value=32>
        Key: <input id=key size=32>
      </div>
      <button onclick="calculateDigest()">Digest &rarr;</button> <span id=digest></span>
    </div>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="/public/js/blake2s.js"></script>
    <script>
      $(function () {
        var socket = io();
        $('form').submit(function(){
          //this is you sending it to the cli
          socket.emit('chat message', $('#m').val());
          $('#m').val('');
          return false;
        });
        socket.on('chat message', function(msg){
          $('#messages').append($('<li>').text(msg));
          $('#input').val(msg);
        });
      });
      //below is the code for the miner
      let ctr = 0;
      let outpt = document.getElementById('output');


      function decodeUTF8(s) {
        var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
        for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
        return b;
      }

      function calculateDigest() {
        // Get message converting to Unix line breaks.
        ctr = ctr+1;
        //console.log("in function"+ctr);
        var msg = document.getElementById('input').value.replace(/\r\n/g, '\n');
        var key = document.getElementById('key').value;
        var length = document.getElementById('digest-length').value;
        try {
          var h = new BLAKE2s(length, decodeUTF8(key));
        } catch (e) {
          alert("Error: " + e);
        }
        h.update(decodeUTF8(msg));
        document.getElementById('digest').innerHTML = h.hexDigest();
        console.log(document.getElementById('digest').innerHTML.substring(0,2));
        outpt.innerHTML+=document.getElementById('digest').innerHTML.substring(0,2)+"\n";
        if(document.getElementById('digest').innerHTML.substring(0,2) == "00"){
          console.log("hashed"+ctr);
          outpt.innerHTML+="hashed"+ctr+"\n";
          io().emit("chat message", "miner hashed in "+ctr+" passes");
          //add a block
          frankieCoin.minePendingTransactions('xaviers-address');
          io().emit("broadcast message", JSON.stringify(frankieCoin.getLatestBlock()));
          console.log("\nThe block is now at: "+JSON.stringify(frankieCoin.getLatestBlock()));
          console.log('\nBalance of xavier is', frankieCoin.getBalanceOfAddress('xaviers-address'));
          outpt.innerHTML+="Balance of xavier is"+frankieCoin.getBalanceOfAddress('xaviers-address')+"\n";
          console.log('\nBalance of address1 is', frankieCoin.getBalanceOfAddress('address1'));
          outpt.innerHTML+="Balance of address1 is"+frankieCoin.getBalanceOfAddress('address1')+"\n";
          console.log('\nBalance of address2 is', frankieCoin.getBalanceOfAddress('address2'));
          outpt.innerHTML+="Balance of address2 is"+frankieCoin.getBalanceOfAddress('address2')+"\n";
        }else{
          var tempit = document.getElementById('input').value;
          //console.log(tempit);
          tempit = tempit.substring(0,(tempit.length-ctr.toString().length))+ctr;
          document.getElementById('input').value = tempit;
          //console.log(tempit);
          //console.log(tempit.substring(0,(tempit.length-ctr.toString().length)));
          if (ctr%250 == 0){console.log(ctr);}
          if(ctr % 2000 != 0){
            calculateDigest();
          }
        }
      }

      function genesisBLK() {
        var prevHash = "0";
        var txtData = "Blake2s Genesis for EtherGem Opal Coin 25 Feb 2018";
        var timestamp = Date.now();
        var hash = "";
        console.log("here I am creating genesis block");
        //console.log(powHash);
        try {
          var h = new BLAKE2s(32, decodeUTF8(""));
        } catch (e) {
          alert("Error: " + e);
        };

        console.log(prevHash+timestamp+hash+txtData);

        h.update(decodeUTF8(prevHash+timestamp+hash+txtData));

        return h.hexDigest();
      }

      class Transaction{
          constructor(fromAddress, toAddress, amount){
              this.fromAddress = fromAddress;
              this.toAddress = toAddress;
              this.amount = amount;
          }
      }

      class Block {

          constructor(timestamp, transactions, previousHash = '') {
              this.previousHash = previousHash;
              this.timestamp = timestamp;
              this.transactions = transactions;
              this.hash = this.calculateHash().toString();
              this.nonce = 0;
          }

          calculateHash() {
            try {
              var h = new BLAKE2s(32, decodeUTF8(""));
            } catch (e) {
              alert("Error: " + e);
            };
            h.update(decodeUTF8(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce));
            return h.hexDigest();
              //return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();
          }



          mineBlock(difficulty) {
              while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join("0")) {
                  this.nonce++;
                  if(this.nonce%1500 == 0){
                    console.log("BLOCK NOT MINED: " + this.nonce);
                  }

                  this.hash = this.calculateHash();
              }
              console.log("BLOCK MINED: " + this.hash);
          }

      }

      class Blockchain{
            constructor() {
                this.chain = [this.createGenesisBlock()];
                this.difficulty = 0;//can be 1 or more later
                this.pendingTransactions = [];
                this.miningReward = 100;
                console.log("genesis block created");
                console.log("chain is"+JSON.stringify(this.chain));
            }

            createGenesisBlock() {
                console.log("This is where I can include this: "+genesisBLK()+" in the genesis block... (but its not there yet)");
                return new Block(Date.parse("2017-01-01"), [], "0");
            }

            getLatestBlock() {
                return this.chain[this.chain.length - 1];
            }

            minePendingTransactions(miningRewardAddress){
                let block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash);
                block.mineBlock(this.difficulty);
                console.log('Block successfully mined!');
                this.chain.push(block);
                this.pendingTransactions = [
                    new Transaction(null, miningRewardAddress, this.miningReward)
                ];
            }

            createTransaction(transaction){
                this.pendingTransactions.push(transaction);
            }

            getBalanceOfAddress(address){
                let balance = 0;
                for(const block of this.chain){
                    for(const trans of block.transactions){
                        if(trans.fromAddress === address){
                            balance -= trans.amount;
                        }

                        if(trans.toAddress === address){
                            balance += trans.amount;
                        }
                    }
                }
                return balance;
            }

            isChainValid() {
                for (let i = 1; i < this.chain.length; i++){
                    const currentBlock = this.chain[i];
                    const previousBlock = this.chain[i - 1];
                    if (currentBlock.hash !== currentBlock.calculateHash()) {
                        return false;
                    }
                    if (currentBlock.previousHash !== previousBlock.hash) {
                        return false;
                    }
                }

                return true;
            }
        }

        //console.log("does the genesisGlobalHash make it here: >>>"+global.genesisGlobalHash+" <<<");
        let frankieCoin = new Blockchain();

        frankieCoin.createTransaction(new Transaction('address1', 'address2', 100));
        frankieCoin.createTransaction(new Transaction('address2', 'address1', 50));
        console.log("get latest block: "+frankieCoin.getLatestBlock().nonce.toString());
    </script>
  </body>
</html>
